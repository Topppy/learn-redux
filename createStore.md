This file is a simple implementation of Observer Pattern

```
import isPlainObject from 'lodash/isPlainObject'
```
> Import a function to checks if `argument` is a plain object, that is, an object created by the * `Object` constructor or one with a  `[[Prototype]]` of `null`. 

```
/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
export var ActionTypes = {
  INIT: '@@redux/INIT'
}
```
ActionTypes is type list contains the only type '@@redux/INIT'. it is used at the end of function **createStore**.



```
export default function createStore(reducer, preloadedState, enhancer) {
  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState
    preloadedState = undefined
  }
```

If there are only two arguments passed in and the type of second one is *Function*, excange the value between **preloadState** and **enhancer**.



```
if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.')
    }

    return enhancer(createStore)(reducer, preloadedState)
  }
```
if enhancer passed in isn't *Function*, tell the user "Error". when the enhancer function is correctly passed in (*The only store enhancer that ships with Redux is `applyMiddleware()`.*), give all the things to enhancer.Also, we can use `applyMiddleware()` in such a way :`applyMiddleware(createStore)(reducer, preloadedState)`.
```
if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.')
  }
```
Make sure reducer is function.
```
  var currentReducer = reducer
  var currentState = preloadedState
  var currentListeners = []
  var nextListeners = currentListeners
  var isDispatching = false
  
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice()
    }
  }
```
*ensureCanMutateNextListeners* ensure nextListeners and curretListeners different.
```
function getState() {
    return currentState
  }
```
Getter of store ,return the current state tree.

```
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.')
    }

    var isSubscribed = true

    ensureCanMutateNextListeners()
    nextListeners.push(listener)

    return function unsubscribe() {
      if (!isSubscribed) {
        return
      }

      isSubscribed = false

      ensureCanMutateNextListeners()
      var index = nextListeners.indexOf(listener)
      nextListeners.splice(index, 1)
    }
  }
  
```
function subscribe is a Closure.It receive a listener and push it into Array nextListeners, set the private flag isSubscribed true, and then return the unsubscribe of the listener.In function unsubscribe, set the flag false and remove the listener from Array nextListeners.
```
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(
        'Actions must be plain objects. ' +
        'Use custom middleware for async actions.'
      )
    }

    if (typeof action.type === 'undefined') {
      throw new Error(
        'Actions may not have an undefined "type" property. ' +
        'Have you misspelled a constant?'
      )
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.')
    }

    try {
      isDispatching = true
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }

    var listeners = currentListeners = nextListeners
    for (var i = 0; i < listeners.length; i++) {
      listeners[i]()
    }

    return action
  }
```
  Here is the well-knoew function dispatch that we use to dispatch an action.Parameter verification of exist and isPlainObject ensure we get the action of type we want. Dispatch can run only when it is not dispatching(the flag isDispatching is false).Give current state and the action to currentReducer, and save the new state generated by reducer.After state is update, notify every listener in nextListeners.
```
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.')
    }

    currentReducer = nextReducer
    dispatch({ type: ActionTypes.INIT })
  }
```
This function update reducer and dispath INIT action.
```
  function observable() {
    var outerSubscribe = subscribe
    return {
      subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.')
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState())
          }
        }

        observeState()
        var unsubscribe = outerSubscribe(observeState)
        return { unsubscribe }
      },

      [$$observable]() {
        return this
      }
    }
  }
```
 Function observable returns an Object contains two propeties ,a method named subscribe and a symbol key return itself.In order to  avoid confusion, we save subscribe as variable outerSubscribe, which is used to add or remove listener from listener list as mentioned before. The property subscribe of Object observable will accept a observer, and notify this observer by function observeState, then push this notify function into listener List by function outerSubscribe.

```
  dispatch({ type: ActionTypes.INIT })

  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }
```
After all, init state by action `{ type: ActionTypes.INIT }`, return an Object contains a series of method.





